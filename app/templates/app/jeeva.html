with serial_data_lock:
        data_to_display = serial_data

    if request.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest':
        # Split the serial data into 11 channels (A-K) using regular expressions
        parts = re.split(r'([A-K])', data_to_display)
        parts = [part for part in parts if part.strip()]  # Remove empty strings

        # Create a dictionary to store data for each channel
        channel_data = {}
        for channel_id, part in zip(parts[0::2], parts[1::2]):
            part = part.replace('+', '')
            channel_data[channel_id] = part

        # Return the channel data as JSON response
        return JsonResponse({'serial_data': channel_data})
    
    # Retrieve the distinct probe IDs
    probe_ids = find.objects.values_list('probe_id', flat=True).distinct()
    
    # Create a dictionary to store coefficient values for each probe ID
    probe_coefficients = {}
    low_count = {}
    
    for probe_id in probe_ids:
        # Retrieve the latest coefficient value for the current probe ID
        latest_calibration = find.objects.filter(probe_id=probe_id).latest('id')
        
        # Extract the coefficient value
        coefficient_value = latest_calibration.coefficent
        low_value = latest_calibration.low_count
        
        
        # Store the coefficient value in the dictionary with the probe ID as the key
        probe_coefficients[probe_id] = coefficient_value
        low_count[probe_id] = low_count

        print(f'Probe ID: {probe_id}, Coefficient: {coefficient_value}')
        print(f'Probe ID: {probe_id}, Low values: {low_value}')
    

    return render(request, 'app/probe.html', {'serial_data': data_to_display ,'probe_coefficients': probe_coefficients ,'low_count':low_count })
