selected_ids = data.get('selectedIDs')
            print("Received data:", selected_ids)

            try:
                # Print each value separately
                for index, item in enumerate(selected_ids):
                    print(f"Item {index + 1}: {item}")
                    
                # Extract part_model and date from selected_ids
                part_model = None
                date = None
                
                for item in selected_ids:
                    if item.startswith('Part Model:'):
                        part_model = item.split(':')[1].strip()
                    if item.startswith('Date:'):
                        date = item.split(':', 1)[1].strip()  # split only on the first colon

                if part_model is None:
                    raise ValueError("Part model not found in selected IDs")
                
                if date is None:
                    raise ValueError("Date not found in selected IDs")
                
                print(f"Extracted Date: {date}")

                

            except ValueError as ve:
                print(f"Error: {ve}")

            except Exception as e:
                print(f"An unexpected error occurred: {e}")








# Retrieve distinct component serial numbers
                comp_sr_no_list = MeasurementData.objects.filter(part_model=part_model).values_list('comp_sr_no', flat=True).distinct()
                print('Distinct component_serial_number jjjjjjjjjjjjjjjjjjj:', comp_sr_no_list)
                # Initialize a dictionary to store part statuses for each component serial number
                part_status_dict = defaultdict(set)

                # Populate the dictionary with distinct part statuses for each component serial number
                for comp_sr_no in comp_sr_no_list:
                    part_statuses = MeasurementData.objects.filter(comp_sr_no=comp_sr_no).values_list('part_status', flat=True).distinct()
                    part_status_dict[comp_sr_no].update(part_statuses)

                # Initialize a dictionary to count each part status
                part_status_count = defaultdict(int)

                # Print the component serial numbers along with their distinct part statuses
                for comp_sr_no, part_statuses in part_status_dict.items():
                    print(f'Component Serial Number: {comp_sr_no}, Part Statuses: {list(part_statuses)}')
                    for status in part_statuses:
                        part_status_count[status] += 1

                # Print the counts for each part status
                print("\nPart Status Counts:")
                for status, count in part_status_count.items():
                    print("your values which is get from the front end:"f'{part_model}{status}: {count}')


                # Reset the values for the specified statuses
                specified_statuses = selected_ids
                for selected_ids in specified_statuses:
                    if selected_ids in part_status_count:
                        part_status_count[selected_ids] = 0

                # Print the counts for each part status after resetting
                print("\nPart Status Counts after resetting:")
                for selected_ids, count in part_status_count.items():
                    print(f'{part_model}{selected_ids}: {count}')

                    # Prepare the response data with the part status counts
                response_data = {selected_ids: part_status_count[selected_ids] for selected_ids in specified_statuses}

                return JsonResponse(response_data)



////////////////////////////////////////////////////////////////////

from django.shortcuts import render
from django.http import JsonResponse
from .models import MeasurementData

def handle_measurement_data(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body.decode('utf-8'))
            part_model = data.get('part_model')
            punch_value = data.get('punch_value')

            if part_model is None:
                return JsonResponse({'status': 'error', 'message': 'part_model not provided'}, status=400)

            if punch_value is None:
                return JsonResponse({'status': 'error', 'message': 'punch_value not provided'}, status=400)

            # Filter MeasurementData objects by part_model
            filtered_data = MeasurementData.objects.filter(part_model=part_model)

            # Check if punch_value already exists
            if filtered_data.filter(comp_sr_no=punch_value).exists():
                return JsonResponse({'status': 'confirm', 'message': 'This punch number already exists. Do you want to overwrite it?'}, status=200)

            # Save the data if punch_value doesn't exist
            data_values = MeasurementData.objects.create(
                parameter_name=data.get('parameterName'),
                readings=data.get('readings'),
                nominal=data.get('nominal'),
                lsl=data.get('lsl'),
                usl=data.get('usl'),
                status_cell=data.get('statusCell'),
                date=date_obj,
                operator=data.get('operator'),
                shift=data.get('shift'),
                machine=data.get('machine'),
                part_model=data.get('partModel'),
                part_status=data.get('partStatus'),
                customer_name=data.get('customerName'),
                comp_sr_no=data.get('compSrNo')
            )
            data_values.save()

            return JsonResponse({'status': 'success', 'message': 'Data saved successfully'}, status=200)

        except json.JSONDecodeError:
            return JsonResponse({'status': 'error', 'message': 'Invalid JSON'}, status=400)
    else:
        return JsonResponse({'status': 'error', 'message': 'Invalid request method'}, status=405)

def delete_existing_punch_value(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body.decode('utf-8'))
            part_model = data.get('part_model')
            punch_value = data.get('punch_value')

            if part_model is None:
                return JsonResponse({'status': 'error', 'message': 'part_model not provided'}, status=400)

            if punch_value is None:
                return JsonResponse({'status': 'error', 'message': 'punch_value not provided'}, status=400)

            # Filter MeasurementData objects by part_model and punch_value
            filtered_data = MeasurementData.objects.filter(part_model=part_model, comp_sr_no=punch_value)

            if filtered_data.exists():
                # Delete the existing entry
                filtered_data.delete()
                return JsonResponse({'status': 'success', 'message': 'Existing entry deleted successfully'}, status=200)
            else:
                return JsonResponse({'status': 'error', 'message': 'No matching entry found to delete'}, status=404)

        except json.JSONDecodeError:
            return JsonResponse({'status': 'error', 'message': 'Invalid JSON'}, status=400)
    else:
        return JsonResponse({'status': 'error', 'message': 'Invalid request method'}, status=405)
